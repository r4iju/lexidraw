import { useState, useCallback } from "react";
import { RuntimeToolMap, useLLM } from "../../context/llm-context";
import { useChatDispatch } from "./llm-chat-context";
import { useRuntimeTools } from "./runtime-tools-provider";
import {
  DEFAULT_SLIDE_DECK_DATA,
  type DeckStrategicMetadata,
  type SlideStrategicMetadata,
} from "../../nodes/SlideNode/SlideNode";

interface AudienceData {
  bigIdea: string;
  persona: string;
  slideCount: number;
  tone: string;
  timebox: string;
  files?: File[];
  existingDeckNodeKey?: string;
}

interface ResearchData {
  findings: string; // or a more structured type
}

interface SlideOutline {
  slideNumber: number;
  title: string;
  keyMessage: string; // could be Markdown bullet points
  visualIdea: string;
  speakerNotes: string;
  pageId?: string; // optional pageId, will be set after slide creation
}

interface StoryboardData {
  slides: SlideOutline[]; // each outline will be augmented with pageId after creation
}

// data structure for content generated by SlideWriter
interface SlideContentData {
  pageId: string; // references the slide page
  contentBoxKey?: string; // key of the Lexical node (e.g., ParagraphNode or a container) holding the main body content
  bodyContent: string; // the generated body content
  refinedSpeakerNotes: string;
}

interface SlideGenerationParams {
  topic: string;
  who: string; // audience
  outcome: string; // desired outcome
  timebox: string; // time constraint
  files?: File[]; // optional files for research
  existingDeckNodeKey?: string;
}

// type for theme settings, mirroring SlideNode.ThemeSettings for state
interface WorkflowThemeSettings {
  templateName?: string;
  colorPalette?: {
    primary?: string;
    secondary?: string;
    accent?: string;
    slideBackground?: string;
    textHeader?: string;
    textBody?: string;
  };
  fonts?: {
    heading?: string;
    body?: string;
    caption?: string;
  };
  logoUrl?: string;
  customTokens?: string; // storing as string, might be JSON
}

// data structure for media/visuals generated by MediaGenerator (Step 6)
interface VisualAssetData {
  pageId: string;
  assetType: "image" | "chart" | "none"; // "none" if visualIdea was present but not actionable or error
  visualIdea: string; // the original visual idea from storyboard
  imagePrompt?: string; // if assetType is 'image'
  imageUrl?: string; // placeholder for now, would be actual URL after generation
  imageId?: string; // key of the actual image node on the slide if created
  chartId?: string; // if assetType is 'chart', this is the nodeKey of the chart
  chartType?: string; // e.g., bar, line, pie
  styleHint?: string;
  error?: string; // if an error occurred for this specific asset
}

export function useSlideCreationWorkflow() {
  const { generateChatResponse } = useLLM();
  const chatDispatch = useChatDispatch();
  const runtimeTools = useRuntimeTools();

  // internal states for workflow data
  const [deckNodeKey, setDeckNodeKey] = useState<string | null>(null);
  const [audienceData, setAudienceData] = useState<AudienceData | null>(null);
  const [researchData, setResearchData] = useState<ResearchData | null>(null);
  const [storyboardData, setStoryboardData] = useState<StoryboardData | null>(
    null,
  );
  const [slideContents, setSlideContents] = useState<SlideContentData[] | null>(
    null,
  );
  const [themeSettings, setThemeSettings] =
    useState<WorkflowThemeSettings | null>(null); // new state for step 5 output
  const [visualAssetsData, setVisualAssetsData] = useState<
    VisualAssetData[] | null
  >(null); // new state for step 6 output
  const [isLoading, setIsLoading] = useState(false);

  const runStep1_AudiencePlanner = useCallback(
    async (
      topic: string,
      who: string,
      outcome: string,
      timebox: string,
    ): Promise<AudienceData | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 1: Audience Planner...",
        },
      });
      const prompt = `You are the *Audience Planner*.
Topic: "${topic}"
Audience: ${who}
Outcome: ${outcome}
Time-box: ${timebox}
▶︎ Provide your response as a JSON object with the keys "bigIdea", "persona", "slideCount" (number), and "tone". Example: {"bigIdea": "Your concise big idea", "persona": "Summary of the audience persona", "slideCount": 10, "tone": "Professional and engaging"}`;

      let rawResponseText = "N/A";
      try {
        const response = await generateChatResponse({
          prompt,
          // no specific tools needed for this step, LLM generates structured text
        });

        if (!response.text) {
          throw new Error("Audience Planner did not return text.");
        }
        rawResponseText = response.text;

        // attempt to parse the response text as JSON
        // clean the response text from potential markdown code blocks
        const cleanedJsonText = response.text
          .replace(/^\s*```json\n?|\n?```\s*$/g, "")
          .trim();
        const parsedData = JSON.parse(cleanedJsonText) as AudienceData;

        // basic validation of the parsed data
        if (
          !parsedData.bigIdea ||
          !parsedData.persona ||
          typeof parsedData.slideCount !== "number" ||
          !parsedData.tone
        ) {
          throw new Error(
            "Audience Planner output is missing required fields or has incorrect types.",
          );
        }

        setAudienceData(parsedData);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "assistant",
            content: `Step 1 Complete: Audience Plan
Big Idea: ${parsedData.bigIdea}
Persona: ${parsedData.persona}
Slide Count: ${parsedData.slideCount}
Tone: ${parsedData.tone}`,
          },
        });
        return parsedData;
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Error in Audience Planner: ${errorMsg}. Raw response: ${rawResponseText}`,
          },
        });
        console.error(
          "Error in Audience Planner:",
          error,
          "Raw response:",
          rawResponseText,
        );
        return null;
      }
    },
    [chatDispatch, generateChatResponse],
  );

  const runStep2_ResearchAgent = useCallback(
    async (
      audienceDataParam: AudienceData,
      files?: File[],
    ): Promise<ResearchData | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 2: Research Agent...",
        },
      });
      const scope = `Based on the Big Idea: '${audienceDataParam.bigIdea}' and audience persona: '${audienceDataParam.persona}', what information is needed?`;
      const prompt = `You are the *Research Agent*.
Inputs: ${files?.map((f) => f.name).join(", ") ?? "None"}
Scope: ${scope}
Constraints: Cite every datum with source + date.
▶︎ Return bullet-point findings, sorted by slide section. If using tools, summarize their output clearly.`;

      // TODO: Define and pass researchTools (webSearchTool, fileReaderTool)
      // For now, we'll assume the LLM can do some basic reasoning or we just get text back
      try {
        const response = await generateChatResponse({
          prompt,
          files, // Pass files if provided
          // tools: researchTools, // This will be added later
        });

        if (!response.text) {
          throw new Error("Research Agent did not return text.");
        }
        const findings = response.text;
        setResearchData({ findings });
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "assistant",
            content: `Step 2 Complete: Research Findings
${findings}`,
          },
        });
        return { findings };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Error in Research Agent: ${errorMsg}`,
          },
        });
        console.error("Error in Research Agent:", error);
        return null;
      }
    },
    [chatDispatch, generateChatResponse],
  );

  const runStep3_StoryboardArchitect = useCallback(
    async (
      researchDataParam: ResearchData,
      slideCount: number,
      _resolvedDeckKeyForThisStep: string,
    ): Promise<StoryboardData | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: `Starting Step 3: Storyboard Architect (target: ${slideCount} slides) for deck ${_resolvedDeckKeyForThisStep}.`,
        },
      });

      const prompt = `You are the *Storyboard Architect*.
Based on the following research findings:
---
${researchDataParam.findings}
---
Create a storyboard for a presentation with approximately ${slideCount} slides.
For each slide, you must define:
1. slideNumber: (integer, starting from 1)
2. title: (string, concise and engaging)
3. keyMessage: (string, bullet points summarizing the core message for this slide, can use markdown)
4. visualIdea: (string, a brief textual description of a potential visual or chart for this slide)
5. speakerNotes: (string, brief notes for the presenter)

▶︎ After creating the array of slide objects, you MUST call the "saveStoryboardOutput" tool and pass the entire array as the "slides" argument to this tool.`;

      try {
        const response = await generateChatResponse({
          prompt,
          tools: {
            saveStoryboardOutput: runtimeTools.saveStoryboardOutput,
          } as RuntimeToolMap,
        });

        // Check for tool call instead of direct text response for storyboard
        if (response.toolCalls && response.toolCalls.length > 0) {
          const toolCall = response.toolCalls[0];
          if (toolCall && toolCall.toolName === "saveStoryboardOutput") {
            const { slides: parsedSlideOutlines } = toolCall.args as {
              slides: SlideOutline[];
            }; // Renamed for clarity

            if (
              !Array.isArray(parsedSlideOutlines) ||
              parsedSlideOutlines.length === 0
            ) {
              throw new Error(
                "saveStoryboardOutput tool did not receive a valid array of slides.",
              );
            }

            const createdSlidesInfo: SlideOutline[] = []; // Will store outlines augmented with pageId
            let slideCreationErrors = 0;

            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "system",
                content: `Processing ${parsedSlideOutlines.length} slide outlines to create pages...`,
              },
            });

            for (const outline of parsedSlideOutlines) {
              const pageId = `${_resolvedDeckKeyForThisStep}-slide-${outline.slideNumber}-${crypto.randomUUID().substring(0, 8)}`;
              const slideMetadataForPage: SlideStrategicMetadata = {
                storyboardTitle: outline.title,
                keyMessage: outline.keyMessage, // Storing raw key message
                keyVisualHint: outline.visualIdea,
                speakerNotes: outline.speakerNotes,
                // purpose, takeAwayMessage, layoutTemplateHint, sourceMaterialRefs can be added later
              };

              if (!runtimeTools.addSlidePage) {
                // This check is a bit redundant if we assume runtimeTools is complete,
                // but good for safety if tools can be dynamically missing.
                throw new Error("addSlidePage tool is not available.");
              }

              // @ts-expect-error - tool parameters are typed as `any` for execute
              const addPageResult = await runtimeTools.addSlidePage.execute({
                deckNodeKey: _resolvedDeckKeyForThisStep,
                newSlideId: pageId,
                slideMetadata: slideMetadataForPage,
                focusNewSlide: false, // Don't shift focus for each created slide during batch creation
              });

              if (addPageResult.success) {
                chatDispatch({
                  type: "push",
                  msg: {
                    id: crypto.randomUUID(),
                    role: "assistant", // Or system, depending on desired visibility
                    content: `Slide page ${outline.slideNumber} ("${outline.title}") created with ID: ${pageId}.`,
                  },
                });
                createdSlidesInfo.push({ ...outline, pageId });
              } else {
                slideCreationErrors++;
                chatDispatch({
                  type: "push",
                  msg: {
                    id: crypto.randomUUID(),
                    role: "system",
                    content: `Error creating slide page ${outline.slideNumber} ("${outline.title}"): ${addPageResult.error || "Unknown error"}`,
                  },
                });
                console.error(
                  `Error creating slide page for outline: ${JSON.stringify(outline)}`,
                  addPageResult.error,
                );
              }
            }

            if (slideCreationErrors > 0) {
              chatDispatch({
                type: "push",
                msg: {
                  id: crypto.randomUUID(),
                  role: "system",
                  content: `Warning: ${slideCreationErrors} slide page(s) could not be created.`,
                },
              });
            }

            const finalStoryboardData = { slides: createdSlidesInfo };
            setStoryboardData(finalStoryboardData);

            const summary = createdSlidesInfo
              .map(
                (s) =>
                  `  Slide ${s.slideNumber} (${s.pageId ? "ID: " + s.pageId.slice(-8) : "Creation Failed"}): ${s.title}`,
              )
              .join("\n");

            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Step 3 Complete: Storyboard processed and ${createdSlidesInfo.length} slide pages created (with ${slideCreationErrors} errors).
Outline & Page IDs:
${summary.substring(0, 1000)}${summary.length > 1000 ? "..." : ""}`,
              },
            });
            return finalStoryboardData; // Return data with pageIds
          } else {
            throw new Error(
              "Storyboard Architect called an unexpected tool or no tool for storyboard output.",
            );
          }
        } else {
          // Fallback or error if no tool call was made but was expected
          const rawResponseText = response.text || "No text response.";
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Error in Storyboard Architect: Expected tool call to saveStoryboardOutput, but received direct text or no tool call. Raw response: ${rawResponseText}`,
            },
          });
          console.error(
            "Error in Storyboard Architect: Expected tool call, got: ",
            response,
          );
          throw new Error(
            "Storyboard Architect did not use the saveStoryboardOutput tool as instructed.",
          );
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Error in Storyboard Architect: ${errorMsg}`,
          },
        });
        console.error("Error in Storyboard Architect:", error);
        return null;
      }
    },
    [chatDispatch, generateChatResponse, runtimeTools],
  );

  const runStep4_SlideWriter = useCallback(
    async (
      storyboardDataParam: StoryboardData,
      currentDeckNodeKey: string,
    ): Promise<SlideContentData[] | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content:
            "Step 4: Slide Writer - Starting to generate content for each slide...",
        },
      });

      const generatedContents: SlideContentData[] = [];
      let contentGenerationErrors = 0;

      if (
        !runtimeTools.saveSlideContentAndNotes ||
        !runtimeTools.addBoxToSlidePage ||
        !runtimeTools.setSlideMetadata
      ) {
        throw new Error(
          "One or more required tools (saveSlideContentAndNotes, addBoxToSlidePage, setSlideMetadata) are not available for Slide Writer.",
        );
      }

      for (const slideOutline of storyboardDataParam.slides) {
        if (!slideOutline.pageId) {
          contentGenerationErrors++;
          console.warn(
            `Skipping slide ${slideOutline.slideNumber} as it has no pageId.`,
          );
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Skipping slide ${slideOutline.slideNumber} ('${slideOutline.title}') for content generation: missing pageId.`,
            },
          });
          continue;
        }

        const initialMetadata = slideOutline; // Contains title, keyMessage, speakerNotes from storyboard

        const prompt = `You are an expert slide content writer.
Slide Title: "${initialMetadata.title}"
Key Message Points: "${initialMetadata.keyMessage}"
Initial Speaker Notes: "${initialMetadata.speakerNotes || "None"}"
Target Audience: [Consider inferring from deck-level metadata if available, or make a general assumption for a professional presentation]

Based on the above, generate the primary text content for the body of this slide. This content should expand on the key message points. Also, review and refine the speaker notes. 

Your response MUST be a call to the "saveSlideContentAndNotes" tool, providing the following arguments:
- "pageId": "${slideOutline.pageId}"
- "bodyContent": (string, the main text for the slide body, can use Markdown for formatting like lists or bolding)
- "refinedSpeakerNotes": (string, your improved speaker notes for this slide)`;

        try {
          const response = await generateChatResponse({
            prompt,
            tools: {
              saveSlideContentAndNotes: runtimeTools.saveSlideContentAndNotes,
            },
          });

          if (
            response.toolCalls &&
            response.toolCalls.length > 0 &&
            response.toolCalls[0]?.toolName === "saveSlideContentAndNotes"
          ) {
            const args = response.toolCalls[0].args as {
              pageId: string;
              bodyContent: string;
              refinedSpeakerNotes: string;
            };

            // 1. Add the bodyContent to a new box on the slide
            // For simplicity, we add a new box. Layout engine will position it.
            // A more advanced version might target specific pre-existing boxes in a template.
            const boxCreationResult =
              // @ts-expect-error - tool parameters are typed as `any` for execute
              await runtimeTools.addBoxToSlidePage.execute({
                deckNodeKey: currentDeckNodeKey,
                slideId: args.pageId, // Use pageId from tool args (should match slideOutline.pageId)
                initialTextContent: args.bodyContent, // This tool creates a simple paragraph with this text
                // Default position/size; Step 7 (Layout Engine) will adjust these.
                // width: 600, height: 400, x: 100, y: 150
              });

            let newContentBoxKey: string | undefined;
            if (
              boxCreationResult.success &&
              boxCreationResult.content?.newNodeKey
            ) {
              newContentBoxKey = boxCreationResult.content.newNodeKey;
              chatDispatch({
                type: "push",
                msg: {
                  id: crypto.randomUUID(),
                  role: "assistant",
                  content: `Content box created for slide ${slideOutline.slideNumber} (pageId: ${args.pageId}). Box Key: ${newContentBoxKey}`,
                },
              });
            } else {
              console.error(
                `Failed to create content box for slide ${args.pageId}: ${boxCreationResult.error}`,
              );
              chatDispatch({
                type: "push",
                msg: {
                  id: crypto.randomUUID(),
                  role: "system",
                  content: `Error creating content box for slide ${slideOutline.slideNumber} (pageId: ${args.pageId}): ${boxCreationResult.error || "Unknown error"}`,
                },
              });
              // Decide if this error is critical enough to increment contentGenerationErrors or throw
            }

            // 2. Update the slide's metadata with the refined speaker notes
            const metadataUpdateResult =
              // @ts-expect-error - tool parameters are typed as `any` for execute
              await runtimeTools.setSlideMetadata.execute({
                deckNodeKey: currentDeckNodeKey,
                slideId: args.pageId,
                slideMetadata: { speakerNotes: args.refinedSpeakerNotes }, // Only update speakerNotes here
              });

            if (!metadataUpdateResult.success) {
              console.warn(
                `Failed to update speaker notes for slide ${args.pageId}: ${metadataUpdateResult.error}`,
              );
              // Non-critical, log and continue
            }

            generatedContents.push({
              pageId: args.pageId,
              bodyContent: args.bodyContent,
              refinedSpeakerNotes: args.refinedSpeakerNotes,
              contentBoxKey: newContentBoxKey,
            });
          } else {
            throw new Error(
              `Expected tool call 'saveSlideContentAndNotes' for slide ${slideOutline.pageId}, but received different or no tool call.`,
            );
          }
        } catch (e) {
          contentGenerationErrors++;
          const errorMsg = e instanceof Error ? e.message : String(e);
          console.error(
            `Error processing slide ${slideOutline.slideNumber} (pageId: ${slideOutline.pageId}): ${errorMsg}`,
          );
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Error generating content for slide ${slideOutline.slideNumber} (pageId: ${slideOutline.pageId}): ${errorMsg}`,
            },
          });
        }
      }

      if (contentGenerationErrors > 0) {
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Warning: Content generation for ${contentGenerationErrors} slide(s) encountered errors.`,
          },
        });
      }

      setSlideContents(generatedContents); // Update state with all generated contents
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "assistant",
          content: `Step 4 Complete: Slide Writer finished generating content for ${generatedContents.length} slides (with ${contentGenerationErrors} errors).`,
        },
      });
      return generatedContents;
    },
    [chatDispatch, generateChatResponse, runtimeTools],
  );

  const runStep5_StyleStylist = useCallback(
    async (
      currentDeckNodeKey: string,
      currentAudienceData: AudienceData | null,
    ): Promise<WorkflowThemeSettings | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 5: Brand & Style Stylist...",
        },
      });

      if (
        !runtimeTools.saveThemeStyleSuggestions ||
        !runtimeTools.setDeckMetadata
      ) {
        throw new Error(
          "Required tools (saveThemeStyleSuggestions, setDeckMetadata) are not available for Style Stylist.",
        );
      }

      const userObjectiveInfo = currentAudienceData
        ? `The presentation's big idea is: "${currentAudienceData.bigIdea}". It is for persona: "${currentAudienceData.persona}" and should have a "${currentAudienceData.tone}" tone.`
        : "The presentation context is not fully defined.";

      const prompt = `You are an expert Brand & Style Specialist.
${userObjectiveInfo}

Suggest a comprehensive visual theme for this presentation. Your suggestions should include:
1.  A "templateName" or general style description (e.g., 'Modern Minimalist', 'Tech Professional', 'Vibrant Startup').
2.  A "colorPalette" with hex codes for: 'primary', 'secondary', 'accent', 'slideBackground', 'textHeader', 'textBody'.
3.  "fonts" with font family names for: 'heading', 'body', 'caption'.
4.  Optionally, a "logoUrl" if you think a placeholder logo would be appropriate (use a generic placeholder URL if so).
5.  Optionally, any "customTokens" as a JSON string for further theme refinements (e.g., specific border styles, shadow effects). Example: '{"cardBorderRadius": "8px"}'.

Your response MUST be a call to the "saveThemeStyleSuggestions" tool, providing these details as arguments. Ensure all color codes are valid hex (e.g., #RRGGBB).`;

      try {
        const response = await generateChatResponse({
          prompt,
          tools: {
            saveThemeStyleSuggestions: runtimeTools.saveThemeStyleSuggestions,
          },
        });

        if (
          response.toolCalls &&
          response.toolCalls.length > 0 &&
          response.toolCalls[0]?.toolName === "saveThemeStyleSuggestions"
        ) {
          const suggestedTheme = response.toolCalls[0]
            .args as WorkflowThemeSettings;

          setThemeSettings(suggestedTheme);

          // Store these theme settings into the DeckNode's metadata
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Updating deck metadata with new theme settings for deck: ${currentDeckNodeKey}...`,
            },
          });

          // @ts-expect-error - tool parameters are typed as `any` for execute
          const setMetadataResult = await runtimeTools.setDeckMetadata.execute({
            deckNodeKey: currentDeckNodeKey,
            // Merge with existing deckMetadata, specifically adding/overwriting the 'theme' property
            deckMetadata: { theme: suggestedTheme },
          });

          if (!setMetadataResult.success) {
            console.warn(
              `Failed to set deck theme metadata: ${setMetadataResult.error || "Unknown error"}`,
            );
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "system",
                content: `Warning: Could not set deck theme metadata. ${setMetadataResult.error || "Unknown error"}`,
              },
            });
          }

          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "assistant",
              content: `Step 5 Complete: Style Stylist suggested theme: ${suggestedTheme.templateName || "Custom Theme"}. Color Palette: ${JSON.stringify(suggestedTheme.colorPalette)}. Fonts: ${JSON.stringify(suggestedTheme.fonts)}. Deck metadata updated.`,
            },
          });
          return suggestedTheme;
        } else {
          throw new Error(
            "Expected tool call 'saveThemeStyleSuggestions', but received different or no tool call.",
          );
        }
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : String(e);
        console.error(`Error in Style Stylist (Step 5): ${errorMsg}`);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Error in Style Stylist: ${errorMsg}`,
          },
        });
        return null;
      }
    },
    [chatDispatch, generateChatResponse, runtimeTools],
  );

  const runStep6_MediaGenerator = useCallback(
    async (
      storyboardDataParam: StoryboardData,
      currentDeckNodeKey: string,
      currentThemeSettings: WorkflowThemeSettings | null,
    ): Promise<VisualAssetData[] | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 6: Media & Chart Generator...",
        },
      });

      const generatedAssets: VisualAssetData[] = [];
      let assetGenerationErrors = 0;

      if (
        !runtimeTools.saveImageGenerationRequest ||
        !runtimeTools.addChartToSlidePage
      ) {
        throw new Error(
          "Required tools (saveImageGenerationRequest, addChartToSlidePage) are not available for Media Generator.",
        );
      }

      const themeStyleHint = currentThemeSettings?.templateName
        ? ` The overall presentation style is '${currentThemeSettings.templateName}'.`
        : "";
      const themeColorsHint = currentThemeSettings?.colorPalette
        ? ` Key theme colors are: ${JSON.stringify(currentThemeSettings.colorPalette)}.`
        : "";

      for (const slideOutline of storyboardDataParam.slides) {
        if (!slideOutline.pageId) {
          console.warn(
            `Skipping media generation for slide ${slideOutline.slideNumber} ('${slideOutline.title}') as it has no pageId.`,
          );
          generatedAssets.push({
            pageId: "unknown",
            visualIdea: slideOutline.visualIdea,
            assetType: "none",
            error: "Missing pageId",
          });
          assetGenerationErrors++;
          continue;
        }
        if (
          !slideOutline.visualIdea ||
          slideOutline.visualIdea.trim().toLowerCase() === "none" ||
          slideOutline.visualIdea.trim() === ""
        ) {
          generatedAssets.push({
            pageId: slideOutline.pageId,
            visualIdea: slideOutline.visualIdea,
            assetType: "none",
          });
          continue; // No visual idea, skip asset generation for this slide
        }

        const prompt = `You are a Visual Asset Coordinator.
For slide ${slideOutline.slideNumber} titled "${slideOutline.title}", the visual idea is: "${slideOutline.visualIdea}".
${themeStyleHint}${themeColorsHint}

Based on this, decide if an image or a chart is most appropriate. 

1.  If an IMAGE is best:
    *   Craft a concise, descriptive prompt for an image generation model (like DALL-E). The prompt should incorporate the visual idea and relevant style hints.
    *   Call the "saveImageGenerationRequest" tool with arguments: "pageId" (use "${slideOutline.pageId}"), "imagePrompt" (your crafted prompt), and "styleHint" (e.g., derived from theme like '${currentThemeSettings?.templateName || "general"}').

2.  If a CHART (bar, line, pie, etc.) is best:
    *   Determine the "chartType".
    *   Synthesize plausible "chartDataJSON" based on the visual idea. This should be a JSON string representing an array of data objects suitable for the chart type (e.g., for a bar chart: '[{"name": "A", "value": 10}, ...]'). Keep data simple (3-5 data points) unless specified otherwise.
    *   Suggest a simple "chartConfigJSON" if applicable (e.g., for Recharts, defining colors or labels as a JSON string: '{"value": {"label": "Sales", "color": "${currentThemeSettings?.colorPalette?.accent || "#8884d8"}"}}'). Often an empty object string '{}' is fine.
    *   Call the "addChartToSlidePage" tool with arguments: "deckNodeKey" (use "${currentDeckNodeKey}"), "slideId" (use "${slideOutline.pageId}"), "chartType", "chartDataJSON", "chartConfigJSON". You can also specify "x", "y", "width", "height" (e.g. x:100, y:200, width:500, height:300) or let the layout engine handle it later. For now, use x:100, y:200, width:500, height:300 if you call this tool.

Choose only ONE tool to call: either "saveImageGenerationRequest" OR "addChartToSlidePage".`;

        try {
          const response = await generateChatResponse({
            prompt,
            tools: {
              saveImageGenerationRequest:
                runtimeTools.saveImageGenerationRequest,
              addChartToSlidePage: runtimeTools.addChartToSlidePage,
            } as RuntimeToolMap,
          });

          if (response.toolCalls && response.toolCalls.length > 0) {
            const toolCall = response.toolCalls[0];
            if (toolCall?.toolName === "saveImageGenerationRequest") {
              const args = toolCall.args as {
                pageId: string;
                imagePrompt: string;
                styleHint?: string;
              };
              // TODO: In a real implementation, call an image generation service here with args.imagePrompt,
              // then get the imageUrl, and then call runtimeTools.addImageToSlidePage.
              // For now, we'll just record the request.
              generatedAssets.push({
                pageId: args.pageId,
                assetType: "image",
                visualIdea: slideOutline.visualIdea,
                imagePrompt: args.imagePrompt,
                styleHint: args.styleHint,
                // imageUrl: placeholderUrl, // Would be set after actual generation
              });
              chatDispatch({
                type: "push",
                msg: {
                  id: crypto.randomUUID(),
                  role: "assistant",
                  content: `Slide ${slideOutline.slideNumber} (Page ID: ${args.pageId}): Image generation requested. Prompt: "${args.imagePrompt.substring(0, 100)}..."`,
                },
              });
            } else if (toolCall?.toolName === "addChartToSlidePage") {
              const args = toolCall.args as {
                deckNodeKey: string;
                slideId: string;
                chartType: string;
                chartDataJSON: string;
                chartConfigJSON: string;
                x?: number;
                y?: number;
                width?: number;
                height?: number;
              };
              // The tool call itself executes addChartToSlidePage, so it's already in the editor.
              // We just need to record its creation from the perspective of the workflow.
              // The tool call doesn't return the chartId (newNodeKey) directly in response.toolCalls[0].args.
              // The execute() function of the tool returns it in its content.newNodeKey.
              // We assume the tool was successful if it was called. A more robust way would be to inspect the tool_results stream if available.

              // For now, we don't have direct access to the execute() return here. So, we will generate a client-side placeholder chartId
              // or accept that the chartId might be missing from generatedAssets if not easily retrievable here.
              // Let's assume the actual chartId/nodeKey will be available if we were to properly await and process tool results.
              // For this step, we'll record what the LLM intended.
              generatedAssets.push({
                pageId: args.slideId,
                assetType: "chart",
                visualIdea: slideOutline.visualIdea,
                chartType: args.chartType,
                chartId: `chart-on-${args.slideId}-${Date.now()}`, // Placeholder, ideally from tool result
              });
              chatDispatch({
                type: "push",
                msg: {
                  id: crypto.randomUUID(),
                  role: "assistant",
                  content: `Slide ${slideOutline.slideNumber} (Page ID: ${args.slideId}): Chart of type '${args.chartType}' requested and addChartToSlidePage tool called.`,
                },
              });
            } else {
              throw new Error(`Unexpected tool called: ${toolCall?.toolName}`);
            }
          } else {
            // LLM didn't call any tool, maybe visualIdea was not actionable
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "system",
                content: `Slide ${slideOutline.slideNumber} (Page ID: ${slideOutline.pageId}): No specific media tool called by LLM for visual idea: "${slideOutline.visualIdea}". Content: ${response.text}`,
              },
            });
            generatedAssets.push({
              pageId: slideOutline.pageId,
              assetType: "none",
              visualIdea: slideOutline.visualIdea,
              error: "LLM did not call a media tool. " + (response.text || ""),
            });
          }
        } catch (e) {
          assetGenerationErrors++;
          const errorMsg = e instanceof Error ? e.message : String(e);
          console.error(
            `Error processing media for slide ${slideOutline.slideNumber} (pageId: ${slideOutline.pageId}): ${errorMsg}`,
          );
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Error generating media for slide ${slideOutline.slideNumber} (pageId: ${slideOutline.pageId}): ${errorMsg}`,
            },
          });
          generatedAssets.push({
            pageId: slideOutline.pageId,
            assetType: "none",
            visualIdea: slideOutline.visualIdea,
            error: errorMsg,
          });
        }
      }

      if (assetGenerationErrors > 0) {
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Warning: Media generation for ${assetGenerationErrors} slide(s) encountered errors or was skipped.`,
          },
        });
      }

      setVisualAssetsData(generatedAssets);
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "assistant",
          content: `Step 6 Complete: Media Generator processed ${generatedAssets.filter((a) => a.assetType !== "none").length} visual ideas (with ${assetGenerationErrors} errors/skips).`,
        },
      });
      return generatedAssets;
    },
    [chatDispatch, generateChatResponse, runtimeTools],
  );

  const runStep7_LayoutEngine = useCallback(
    async (
      currentDeckNodeKey: string,
      allSlideContents: SlideContentData[] | null,
      allVisualAssets: VisualAssetData[] | null,
      // currentThemeSettings: WorkflowThemeSettings | null // Not used in programmatic version yet
    ): Promise<void> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 7: Layout Engine (Programmatic)...",
        },
      });

      if (
        !runtimeTools.updateBoxPropertiesOnSlidePage ||
        !runtimeTools.updateSlideElementProperties
      ) {
        throw new Error(
          "Required tools (updateBoxPropertiesOnSlidePage, updateSlideElementProperties) are not available for Layout Engine.",
        );
      }

      const SLIDE_WIDTH = 1280;
      const SLIDE_HEIGHT = 720;
      const PADDING = 50;
      const GAP = 40;

      const pageIds = new Set<string>();
      if (allSlideContents)
        allSlideContents.forEach((sc) => pageIds.add(sc.pageId));
      if (allVisualAssets)
        allVisualAssets.forEach((va) => pageIds.add(va.pageId));

      let layoutErrors = 0;

      for (const pageId of pageIds) {
        const content = allSlideContents?.find((sc) => sc.pageId === pageId);
        const visual = allVisualAssets?.find(
          (va) =>
            va.pageId === pageId &&
            (va.assetType === "chart" || va.assetType === "image"),
        );

        try {
          if (
            content?.contentBoxKey &&
            visual &&
            (visual.chartId || visual.imageId)
          ) {
            // Two-column layout: Text Left, Visual Right
            const textWidth = (SLIDE_WIDTH - 2 * PADDING - GAP) / 2;
            const visualWidth = textWidth;
            const elementHeight = SLIDE_HEIGHT - 2 * PADDING;

            // Update text box (contentBoxKey)
            const textUpdateResult =
              // @ts-expect-error - tool parameters are typed as `any` for execute
              await runtimeTools.updateBoxPropertiesOnSlidePage.execute({
                deckNodeKey: currentDeckNodeKey,
                slideId: pageId,
                boxId: content.contentBoxKey,
                properties: {
                  x: PADDING,
                  y: PADDING,
                  width: textWidth,
                  height: elementHeight,
                },
              });
            if (!textUpdateResult.success)
              throw new Error(
                `Failed to update text box ${content.contentBoxKey}: ${textUpdateResult.error}`,
              );

            // Update visual asset
            const visualElementId =
              visual.assetType === "chart" ? visual.chartId : visual.imageId;
            if (!visualElementId)
              throw new Error("Visual element ID missing for layout.");

            const visualUpdateResult =
              // @ts-expect-error - tool parameters are typed as `any` for execut
              await runtimeTools.updateSlideElementProperties.execute({
                deckNodeKey: currentDeckNodeKey,
                slideId: pageId,
                elementId: visualElementId,
                kind: visual.assetType, // 'chart' or 'image'
                properties: {
                  x: PADDING + textWidth + GAP,
                  y: PADDING,
                  width: visualWidth,
                  height: elementHeight,
                },
              });
            if (!visualUpdateResult.success)
              throw new Error(
                `Failed to update visual ${visualElementId}: ${visualUpdateResult.error}`,
              );

            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Applied two-column layout to slide ${pageId}.`,
              },
            });
          } else if (content?.contentBoxKey) {
            // Only text content: make it wide, centered vertically for now
            const textWidth = SLIDE_WIDTH - 2 * PADDING;
            const textHeight = SLIDE_HEIGHT / 2; // Example: half height
            // @ts-expect-error - tool parameters are typed as `any` for execute
            await runtimeTools.updateBoxPropertiesOnSlidePage.execute({
              deckNodeKey: currentDeckNodeKey,
              slideId: pageId,
              boxId: content.contentBoxKey,
              properties: {
                x: PADDING,
                y: (SLIDE_HEIGHT - textHeight) / 2,
                width: textWidth,
                height: textHeight,
              },
            });
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Applied full-width layout to text box on slide ${pageId}.`,
              },
            });
          } else if (visual && (visual.chartId || visual.imageId)) {
            // Only visual content: center it
            const visualWidth = SLIDE_WIDTH / 2;
            const visualHeight = SLIDE_HEIGHT / 1.5;
            const visualElementId =
              visual.assetType === "chart" ? visual.chartId : visual.imageId;
            if (!visualElementId)
              throw new Error("Visual element ID missing for layout.");
            // @ts-expect-error - tool parameters are typed as `any` for execute
            await runtimeTools.updateSlideElementProperties.execute({
              deckNodeKey: currentDeckNodeKey,
              slideId: pageId,
              elementId: visualElementId,
              kind: visual.assetType,
              properties: {
                x: (SLIDE_WIDTH - visualWidth) / 2,
                y: (SLIDE_HEIGHT - visualHeight) / 2,
                width: visualWidth,
                height: visualHeight,
              },
            });
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Centered visual asset on slide ${pageId}.`,
              },
            });
          }
        } catch (e) {
          layoutErrors++;
          const errorMsg = e instanceof Error ? e.message : String(e);
          console.error(`Error laying out slide ${pageId}: ${errorMsg}`);
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Error applying layout to slide ${pageId}: ${errorMsg}`,
            },
          });
        }
      }

      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "assistant",
          content: `Step 7 Complete: Layout Engine finished applying programmatic layouts to ${pageIds.size} slide(s) (with ${layoutErrors} errors).`,
        },
      });
      // This function doesn't return a new state object for the workflow, as it modifies existing nodes.
      // It could return a summary or error status if needed.
    },
    [chatDispatch, runtimeTools],
  );

  const runStep8_ReviewRefine = useCallback(
    async (
      _currentDeckNodeKey: string,
      _audienceData: AudienceData | null,
      _storyboardData: StoryboardData | null,
      _slideContents: SlideContentData[] | null,
      _themeSettings: WorkflowThemeSettings | null,
      _visualAssetsData: VisualAssetData[] | null,
    ): Promise<{ finalSummary: string }> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 8: Review & Refine...",
        },
      });

      // For now, this step is a placeholder.
      // Future enhancements could involve LLM-based review or user interaction.

      const summaryLines = [
        "Step 8: Review & Refine Complete (Placeholder)",
        `- Deck Node Key: ${_currentDeckNodeKey}`,
        `- Audience Big Idea: ${_audienceData?.bigIdea || "N/A"}`,
        `- Number of Slides in Storyboard: ${_storyboardData?.slides?.length || 0}`,
        `- Number of Slides with Generated Content: ${_slideContents?.length || 0}`,
        `- Theme Template: ${_themeSettings?.templateName || "N/A"}`,
        `- Visual Assets Processed: ${_visualAssetsData?.filter((va) => va.assetType !== "none").length || 0} (out of ${_visualAssetsData?.length || 0} visual ideas)`,
      ];

      const finalSummary = summaryLines.join("\n");

      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "assistant",
          content: finalSummary,
        },
      });

      return { finalSummary };
    },
    [chatDispatch],
  );

  const startSlideGeneration = useCallback(
    async (params: SlideGenerationParams) => {
      setIsLoading(true);
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Slide generation workflow initiated...",
        },
      });

      //This variable will hold the deck key for the current execution of the workflow.
      //It's initialized from state (if a deck was previously worked on) or set by creating/receiving a key.
      let resolvedDeckNodeKey: string | null = deckNodeKey;

      try {
        if (params.existingDeckNodeKey) {
          resolvedDeckNodeKey = params.existingDeckNodeKey;
          setDeckNodeKey(resolvedDeckNodeKey);
        } else if (!resolvedDeckNodeKey) {
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: "Creating new slide deck...",
            },
          });
          if (!runtimeTools.insertSlideDeckNode) {
            throw new Error("insertSlideDeckNode tool is not available.");
          }
          const deckCreationResult =
            // @ts-expect-error - tool parameters are typed as `any` for execute
            await runtimeTools.insertSlideDeckNode.execute({
              initialDataJSON: JSON.stringify(DEFAULT_SLIDE_DECK_DATA),
              relation: "appendRoot",
            });

          if (
            deckCreationResult.success &&
            deckCreationResult.content?.newNodeKey
          ) {
            resolvedDeckNodeKey = deckCreationResult.content.newNodeKey;
            setDeckNodeKey(resolvedDeckNodeKey);
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `New slide deck created with key: ${resolvedDeckNodeKey}`,
              },
            });
          } else {
            throw new Error(
              `Failed to create new slide deck: ${deckCreationResult.error || "Unknown error"}`,
            );
          }
        }

        if (!resolvedDeckNodeKey) {
          throw new Error(
            "Slide deck node key could not be resolved or created.",
          );
        }

        const step1Result = await runStep1_AudiencePlanner(
          params.topic,
          params.who,
          params.outcome,
          params.timebox,
        );
        if (!step1Result) throw new Error("Audience planning failed (step 1)");

        const deckMetadataForStep1: DeckStrategicMetadata = {
          bigIdea: step1Result.bigIdea,
          audiencePersonaSummary: step1Result.persona,
          targetSlideCount: step1Result.slideCount,
          recommendedTone: step1Result.tone,
          originalUserPrompt: `Topic: ${params.topic}, Audience: ${params.who}, Outcome: ${params.outcome}, Timebox: ${params.timebox}`,
        };

        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Setting initial deck metadata for deck: ${resolvedDeckNodeKey}...`,
          },
        });

        if (!runtimeTools.setDeckMetadata) {
          throw new Error("setDeckMetadata tool is not available.");
        }
        const setInitialMetadataResult =
          // @ts-expect-error - tool parameters are typed as `any` for execute
          await runtimeTools.setDeckMetadata.execute({
            deckNodeKey: resolvedDeckNodeKey,
            deckMetadata: deckMetadataForStep1,
          });

        if (!setInitialMetadataResult.success) {
          console.warn(
            `Failed to set initial deck metadata: ${setInitialMetadataResult.error || "Unknown error"}`,
          );
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Warning: Could not set initial deck metadata. ${setInitialMetadataResult.error || "Unknown error"}`,
            },
          });
        }
        // Pass step1Result (AudienceData) to StyleStylist as it contains relevant info
        const step5Result = await runStep5_StyleStylist(
          resolvedDeckNodeKey,
          step1Result,
        );
        if (!step5Result) throw new Error("Style Stylist failed (step 5)");

        const step2Result = await runStep2_ResearchAgent(
          step1Result,
          params.files,
        );
        if (!step2Result) throw new Error("Research failed (step 2)");

        // Pass the definitively resolved string key to step 3
        const step3Result = await runStep3_StoryboardArchitect(
          step2Result,
          step1Result.slideCount,
          resolvedDeckNodeKey,
        );
        if (!step3Result)
          throw new Error("Storyboard Architect failed (step 3)");

        const step4Result = await runStep4_SlideWriter(
          step3Result,
          resolvedDeckNodeKey,
        );
        if (!step4Result) throw new Error("Slide Writer failed (step 4)");

        const step6Result = await runStep6_MediaGenerator(
          step3Result,
          resolvedDeckNodeKey,
          step5Result,
        );
        if (!step6Result) throw new Error("Media Generator failed (step 6)");

        await runStep7_LayoutEngine(
          resolvedDeckNodeKey,
          step4Result, // SlideContentData[]
          step6Result, // VisualAssetData[] | null -- OOPS, this should be step5Result (ThemeSettings)
        );
        // Step 7 doesn't return a value to check against step7Result, so we just proceed
        // if (!step7Result) throw new Error("Layout Engine failed (step 7)");

        const step8Result = await runStep8_ReviewRefine(
          resolvedDeckNodeKey,
          step1Result,
          step3Result,
          step4Result,
          step5Result,
          step6Result,
        );
        if (!step8Result) throw new Error("Review & Refine failed (step 8)");

        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system", // Changed to system as it's a final workflow status meta-message
            content: `Slide generation workflow steps concluded. Final summary from Review & Refine: ${step8Result.finalSummary}`,
          },
        });
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        console.error("Slide generation workflow failed:", error);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Workflow error: ${errorMsg}`,
          },
        });
      } finally {
        setIsLoading(false);
      }
    },
    [
      chatDispatch,
      // generateChatResponse, // Not directly used here, but by sub-steps
      runStep1_AudiencePlanner,
      runStep2_ResearchAgent,
      runStep3_StoryboardArchitect,
      runStep4_SlideWriter,
      runStep5_StyleStylist,
      runStep6_MediaGenerator,
      runStep7_LayoutEngine,
      runStep8_ReviewRefine,
      deckNodeKey, // Hook state dependency
      runtimeTools, // Hook dependency
    ],
  );

  return {
    startSlideGeneration,
    isLoading,
    audienceData,
    researchData,
    storyboardData,
    deckNodeKey,
    slideContents,
    themeSettings, // Expose new state
    visualAssetsData, // Expose new state
  };
}
