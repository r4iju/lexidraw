import { useState, useCallback } from "react";
import { RuntimeToolMap, useLLM } from "../../context/llm-context";
import { useChatDispatch } from "./llm-chat-context";
import { useRuntimeTools } from "./runtime-tools-provider";
import {
  type DeckStrategicMetadata,
  type SlideStrategicMetadata,
} from "../../nodes/SlideNode/SlideNode";

interface AudienceData {
  bigIdea: string;
  persona: string;
  slideCount: number;
  tone: string;
  timebox: string;
  files?: File[];
  existingDeckNodeKey?: string;
}

interface ResearchData {
  findings: string; // or a more structured type
}

interface SlideOutline {
  slideNumber: number;
  title: string;
  keyMessage: string; // could be Markdown bullet points
  visualIdea: string;
  speakerNotes: string;
  pageId?: string; // optional pageId, will be set after slide creation
  styleHint?: string;
}

interface StoryboardData {
  slides: SlideOutline[]; // each outline will be augmented with pageId after creation
}

// data structure for content generated by SlideWriter
interface SlideContentData {
  pageId: string; // references the slide page
  structuredBodyContent: { type: string; text: string }[]; // Now an array of objects
  refinedSpeakerNotes: string;
}

interface SlideGenerationParams {
  topic: string;
  who: string; // audience
  outcome: string; // desired outcome
  timebox: string; // time constraint
  files?: File[]; // optional files for research
  existingDeckNodeKey?: string;
}

// type for theme settings, mirroring SlideNode.ThemeSettings for state
interface WorkflowThemeSettings {
  templateName?: string;
  colorPalette?: {
    primary?: string;
    secondary?: string;
    accent?: string;
    slideBackground?: string;
    textHeader?: string;
    textBody?: string;
  };
  fonts?: {
    heading?: string;
    body?: string;
    caption?: string;
  };
  logoUrl?: string;
  customTokens?: string; // storing as string, might be JSON
}

// data structure for media/visuals generated by MediaGenerator (Step 6)
interface VisualAssetData {
  pageId: string;
  assetType: "image" | "chart" | "none"; // "none" if visualIdea was present but not actionable or error
  visualIdea: string; // the original visual idea from storyboard
  imagePrompt?: string; // if assetType is 'image'
  imageUrl?: string; // placeholder for now, would be actual URL after generation
  imageId?: string; // key of the actual image node on the slide if created
  chartId?: string; // if assetType is 'chart', this is the nodeKey of the chart
  chartType?: string; // e.g., bar, line, pie
  styleHint?: string;
  error?: string; // if an error occurred for this specific asset
}

// For typing the result of tool calls like addChartToSlidePage
interface ToolExecutionResultForMedia {
  success: boolean;
  content?: {
    summary: string;
    newNodeKey?: string; // This is the crucial part
    updatedEditorStateJson?: string;
  };
  error?: string;
}

export function useSlideCreationWorkflow() {
  const { generateChatResponse } = useLLM();
  const chatDispatch = useChatDispatch();
  const runtimeTools = useRuntimeTools();

  // internal states for workflow data
  const [deckNodeKey, setDeckNodeKey] = useState<string | null>(null);
  const [audienceData, setAudienceData] = useState<AudienceData | null>(null);
  const [researchData, setResearchData] = useState<ResearchData | null>(null);
  const [storyboardData, setStoryboardData] = useState<StoryboardData | null>(
    null,
  );
  const [slideContents, setSlideContents] = useState<SlideContentData[] | null>(
    null,
  );
  const [themeSettings, setThemeSettings] =
    useState<WorkflowThemeSettings | null>(null); // new state for step 5 output
  const [visualAssetsData, setVisualAssetsData] = useState<
    VisualAssetData[] | null
  >(null); // new state for step 6 output
  const [isLoading, setIsLoading] = useState(false);

  const runStep1_AudiencePlanner = useCallback(
    async (
      topic: string,
      who: string,
      outcome: string,
      timebox: string,
    ): Promise<AudienceData | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 1: Audience Planner...",
        },
      });
      const prompt = `You are the *Audience Planner*.
Topic: "${topic}"
Audience: ${who}
Outcome: ${outcome}
Time-box: ${timebox}
▶︎ Provide your response as a JSON object with the keys "bigIdea", "persona", "slideCount" (number), and "tone". Example: {"bigIdea": "Your concise big idea", "persona": "Summary of the audience persona", "slideCount": 10, "tone": "Professional and engaging"}`;

      let rawResponseText = "N/A";
      try {
        const response = await generateChatResponse({
          prompt,
          // no specific tools needed for this step, LLM generates structured text
        });

        if (!response.text) {
          throw new Error("Audience Planner did not return text.");
        }
        rawResponseText = response.text;

        // attempt to parse the response text as JSON
        // clean the response text from potential markdown code blocks
        const cleanedJsonText = response.text
          .replace(/^\s*```json\n?|\n?```\s*$/g, "")
          .trim();
        const parsedData = JSON.parse(cleanedJsonText) as AudienceData;

        // basic validation of the parsed data
        if (
          !parsedData.bigIdea ||
          !parsedData.persona ||
          typeof parsedData.slideCount !== "number" ||
          !parsedData.tone
        ) {
          throw new Error(
            "Audience Planner output is missing required fields or has incorrect types.",
          );
        }

        setAudienceData(parsedData);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "assistant",
            content: `Step 1 Complete: Audience Plan
Big Idea: ${parsedData.bigIdea}
Persona: ${parsedData.persona}
Slide Count: ${parsedData.slideCount}
Tone: ${parsedData.tone}`,
          },
        });
        return parsedData;
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Error in Audience Planner: ${errorMsg}. Raw response: ${rawResponseText}`,
          },
        });
        console.error(
          "Error in Audience Planner:",
          error,
          "Raw response:",
          rawResponseText,
        );
        return null;
      }
    },
    [chatDispatch, generateChatResponse],
  );

  const runStep2_StyleStylist = useCallback(
    async (
      currentDeckNodeKey: string,
      currentAudienceData: AudienceData | null,
    ): Promise<WorkflowThemeSettings | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 2: Brand & Style Stylist...",
        },
      });

      if (
        !runtimeTools.saveThemeStyleSuggestions ||
        !runtimeTools.setDeckMetadata
      ) {
        throw new Error(
          "Required tools (saveThemeStyleSuggestions, setDeckMetadata) are not available for Style Stylist.",
        );
      }

      const userObjectiveInfo = currentAudienceData
        ? `The presentation's big idea is: "${currentAudienceData.bigIdea}". It is for persona: "${currentAudienceData.persona}" and should have a "${currentAudienceData.tone}" tone.`
        : "The presentation context is not fully defined.";

      const prompt = `You are an expert Brand & Style Specialist.
${userObjectiveInfo}

Suggest a comprehensive visual theme for this presentation. Your suggestions should include:
1.  A "templateName" or general style description (e.g., 'Modern Minimalist', 'Tech Professional', 'Vibrant Startup').
2.  A "colorPalette" with hex codes for: 'primary', 'secondary', 'accent', 'slideBackground', 'textHeader', 'textBody'.
3.  "fonts" with font family names for: 'heading', 'body', 'caption'.
4.  Optionally, a "logoUrl" if you think a placeholder logo would be appropriate (use a generic placeholder URL if so).
5.  Optionally, any "customTokens" as a JSON string for further theme refinements (e.g., specific border styles, shadow effects). Example: '{"cardBorderRadius": "8px"}'.

Your response MUST be a call to the "saveThemeStyleSuggestions" tool, providing these details as arguments. Ensure all color codes are valid hex (e.g., #RRGGBB).`;

      try {
        const response = await generateChatResponse({
          prompt,
          tools: {
            saveThemeStyleSuggestions: runtimeTools.saveThemeStyleSuggestions,
          },
        });

        if (
          response.toolCalls &&
          response.toolCalls.length > 0 &&
          response.toolCalls[0]?.toolName === "saveThemeStyleSuggestions"
        ) {
          const suggestedTheme = response.toolCalls[0]
            .args as WorkflowThemeSettings;

          setThemeSettings(suggestedTheme);

          // Store these theme settings into the DeckNode's metadata
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Updating deck metadata with new theme settings for deck: ${currentDeckNodeKey}...`,
            },
          });

          // @ts-expect-error - tool parameters are typed as `any` for execute
          const setMetadataResult = await runtimeTools.setDeckMetadata.execute({
            deckNodeKey: currentDeckNodeKey,
            // Merge with existing deckMetadata, specifically adding/overwriting the 'theme' property
            deckMetadata: { theme: suggestedTheme },
          });

          if (!setMetadataResult.success) {
            console.warn(
              `Failed to set deck theme metadata: ${setMetadataResult.error || "Unknown error"}`,
            );
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "system",
                content: `Warning: Could not set deck theme metadata. ${setMetadataResult.error || "Unknown error"}`,
              },
            });
          }

          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "assistant",
              content: `Step 2 Complete: Style Stylist suggested theme: ${suggestedTheme.templateName || "Custom Theme"}. Color Palette: ${JSON.stringify(suggestedTheme.colorPalette)}. Fonts: ${JSON.stringify(suggestedTheme.fonts)}. Deck metadata updated.`,
            },
          });
          return suggestedTheme;
        } else {
          throw new Error(
            "Expected tool call 'saveThemeStyleSuggestions', but received different or no tool call.",
          );
        }
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : String(e);
        console.error(`Error in Style Stylist (Step 2): ${errorMsg}`);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Error in Style Stylist: ${errorMsg}`,
          },
        });
        return null;
      }
    },
    [chatDispatch, generateChatResponse, runtimeTools],
  );

  const runStep3_ResearchAgent = useCallback(
    async (
      audienceDataParam: AudienceData,
      files?: File[],
    ): Promise<ResearchData | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 3: Research Agent...",
        },
      });
      const scope = `Based on the Big Idea: '${audienceDataParam.bigIdea}' and audience persona: '${audienceDataParam.persona}', what information is needed?`;
      const prompt = `You are the *Research Agent*.
Inputs: ${files?.map((f) => f.name).join(", ") ?? "None"}
Scope: ${scope}
Constraints: Cite every datum with source + date.
▶︎ Return bullet-point findings, sorted by slide section. If using tools, summarize their output clearly.`;

      // TODO: Define and pass researchTools (webSearchTool, fileReaderTool)
      // For now, we'll assume the LLM can do some basic reasoning or we just get text back
      try {
        const response = await generateChatResponse({
          prompt,
          files, // Pass files if provided
          // tools: researchTools, // This will be added later
        });

        if (!response.text) {
          throw new Error("Research Agent did not return text.");
        }
        const findings = response.text;
        setResearchData({ findings });
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "assistant",
            content: `Step 3 Complete: Research Findings
${findings}`,
          },
        });
        return { findings };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Error in Research Agent: ${errorMsg}`,
          },
        });
        console.error("Error in Research Agent:", error);
        return null;
      }
    },
    [chatDispatch, generateChatResponse],
  );

  const runStep4_StoryboardArchitect = useCallback(
    async (
      researchDataParam: ResearchData,
      slideCount: number,
      _resolvedDeckKeyForThisStep: string,
    ): Promise<StoryboardData | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: `Starting Step 4: Storyboard Architect (target: ${slideCount} slides) for deck ${_resolvedDeckKeyForThisStep}.`,
        },
      });

      const prompt = `You are the *Storyboard Architect*.
Based on the following research findings:
---
${researchDataParam.findings}
---
Create a storyboard for a presentation with approximately ${slideCount} slides.
For each slide, you must define:
1. slideNumber: (integer, starting from 1)
2. title: (string, concise and engaging)
3. keyMessage: (string, bullet points summarizing the core message for this slide, can use markdown)
4. visualIdea: (string, a brief textual description of a potential visual or chart for this slide)
5. speakerNotes: (string, brief notes for the presenter)

▶︎ Generate the storyboard as an array of slide objects. Provide this array *only* through the "slides" argument of the "saveStoryboardOutput" tool. Your entire response must be *only* this single tool call. Do not include any other text, explanations, or summaries in your response.`;

      console.log(
        "runtimeTools.saveStoryboardOutput",
        runtimeTools.saveStoryboardOutput,
      );
      try {
        const response = await generateChatResponse({
          prompt,
          tools: {
            saveStoryboardOutput: runtimeTools.saveStoryboardOutput,
          } as RuntimeToolMap,
        });

        if (response.toolCalls && response.toolCalls.length > 0) {
          const toolCall = response.toolCalls[0];
          if (toolCall && toolCall.toolName === "saveStoryboardOutput") {
            const { slides: parsedSlideOutlines } = toolCall.args as {
              slides: SlideOutline[];
            };

            if (
              !Array.isArray(parsedSlideOutlines) ||
              parsedSlideOutlines.length === 0
            ) {
              throw new Error(
                "saveStoryboardOutput tool did not receive a valid array of slides.",
              );
            }

            const createdSlidesInfo: SlideOutline[] = []; // will store outlines augmented with pageId
            let slideCreationErrors = 0;

            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "system",
                content: `Processing ${parsedSlideOutlines.length} slide outlines to create pages...`,
              },
            });

            for (const outline of parsedSlideOutlines) {
              const pageId = `${_resolvedDeckKeyForThisStep}-slide-${outline.slideNumber}-${crypto.randomUUID().substring(0, 8)}`;
              const slideMetadataForPage: SlideStrategicMetadata = {
                storyboardTitle: outline.title,
                keyMessage: outline.keyMessage, // Storing raw key message
                keyVisualHint: outline.visualIdea,
                speakerNotes: outline.speakerNotes,
                // purpose, takeAwayMessage, layoutTemplateHint, sourceMaterialRefs can be added later
              };

              if (!runtimeTools.addSlidePage) {
                // This check is a bit redundant if we assume runtimeTools is complete,
                // but good for safety if tools can be dynamically missing.
                throw new Error("addSlidePage tool is not available.");
              }

              // @ts-expect-error - tool parameters are typed as `any` for execute
              const addPageResult = await runtimeTools.addSlidePage.execute({
                deckNodeKey: _resolvedDeckKeyForThisStep,
                newSlideId: pageId,
                slideMetadata: slideMetadataForPage,
                focusNewSlide: false, // Don't shift focus for each created slide during batch creation
              });

              if (addPageResult.success) {
                chatDispatch({
                  type: "push",
                  msg: {
                    id: crypto.randomUUID(),
                    role: "assistant", // Or system, depending on desired visibility
                    content: `Slide page ${outline.slideNumber} ("${outline.title}") created with ID: ${pageId}.`,
                  },
                });
                createdSlidesInfo.push({ ...outline, pageId });
              } else {
                slideCreationErrors++;
                chatDispatch({
                  type: "push",
                  msg: {
                    id: crypto.randomUUID(),
                    role: "system",
                    content: `Error creating slide page ${outline.slideNumber} ("${outline.title}"): ${addPageResult.error || "Unknown error"}`,
                  },
                });
                console.error(
                  `Error creating slide page for outline: ${JSON.stringify(outline)}`,
                  addPageResult.error,
                );
              }
            }

            if (slideCreationErrors > 0) {
              chatDispatch({
                type: "push",
                msg: {
                  id: crypto.randomUUID(),
                  role: "system",
                  content: `Warning: ${slideCreationErrors} slide page(s) could not be created.`,
                },
              });
            }

            const finalStoryboardData = { slides: createdSlidesInfo };
            setStoryboardData(finalStoryboardData);

            const summary = createdSlidesInfo
              .map(
                (s) =>
                  `  Slide ${s.slideNumber} (${s.pageId ? "ID: " + s.pageId.slice(-8) : "Creation Failed"}): ${s.title}`,
              )
              .join("\n");

            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Step 4 Complete: Storyboard processed and ${createdSlidesInfo.length} slide pages created (with ${slideCreationErrors} errors).
Outline & Page IDs:
${summary.substring(0, 1000)}${summary.length > 1000 ? "..." : ""}`,
              },
            });
            return finalStoryboardData; // Return data with pageIds
          } else {
            throw new Error(
              "Storyboard Architect called an unexpected tool or no tool for storyboard output.",
            );
          }
        } else {
          // Fallback or error if no tool call was made but was expected
          const rawResponseText = response.text || "No text response.";
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Error in Storyboard Architect: Expected tool call to saveStoryboardOutput, but received direct text or no tool call. Raw response: ${rawResponseText}`,
            },
          });
          console.error(
            "Error in Storyboard Architect: Expected tool call, got: ",
            response,
          );
          throw new Error(
            "Storyboard Architect did not use the saveStoryboardOutput tool as instructed.",
          );
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Error in Storyboard Architect: ${errorMsg}`,
          },
        });
        console.error("Error in Storyboard Architect:", error);
        return null;
      }
    },
    [chatDispatch, generateChatResponse, runtimeTools],
  );

  const runStep5_SlideWriter = useCallback(
    async (
      storyboardDataParam: StoryboardData,
      currentDeckNodeKey: string,
    ): Promise<SlideContentData[] | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content:
            "Starting Step 5: Slide Writer - Generating structured content for each slide...",
        },
      });
      const generatedContents: SlideContentData[] = [];
      let contentGenerationErrors = 0;

      if (
        !runtimeTools.saveSlideContentAndNotes ||
        !runtimeTools.setSlideMetadata
      ) {
        throw new Error(
          "One or more required tools (saveSlideContentAndNotes, setSlideMetadata) are not available for Slide Writer.",
        );
      }

      for (const slideOutline of storyboardDataParam.slides) {
        if (!slideOutline.pageId) {
          contentGenerationErrors++;
          console.warn(
            `Skipping slide ${slideOutline.slideNumber} as it has no pageId.`,
          );
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Skipping slide ${slideOutline.slideNumber} ('${slideOutline.title}') for content generation: missing pageId.`,
            },
          });
          continue;
        }

        const initialMetadata = slideOutline;

        const prompt = `You are an expert slide content writer.
Slide Title: "${initialMetadata.title}"
Key Message Points: "${initialMetadata.keyMessage}"
Initial Speaker Notes: "${initialMetadata.speakerNotes || "None"}"
Target Audience: [Consider inferring from deck-level metadata if available, or make a general assumption for a professional presentation]

Based on the above, generate the primary content for the body of this slide and refine the speaker notes.
The slide body content should be provided as a JSON array of content block objects. Each block object must have a "type" (string) and a "text" (string) property.
Valid types are: "heading1", "heading2", "paragraph", "bulletList".
For "bulletList", the "text" property should be a single string with items separated by newlines (e.g., "Item 1\nItem 2").

Example of the "bodyContent" argument value:
[{"type": "heading2", "text": "Key Achievements"}, {"type": "bulletList", "text": "Launched Product X\nReached 1M Users\nSecured Series A Funding"}]

Your response MUST be a call to the "saveSlideContentAndNotes" tool, providing the following arguments:
- "pageId": "${slideOutline.pageId}"
- "bodyContent": (JSON array of objects, the structured content as described above)
- "refinedSpeakerNotes": (string, your improved speaker notes for this slide)
Do NOT call any other tools, such as styling tools. Your sole purpose is to provide content via the "saveSlideContentAndNotes" tool.`;

        try {
          const response = await generateChatResponse({
            prompt,
            tools: {
              saveSlideContentAndNotes: runtimeTools.saveSlideContentAndNotes,
            },
          });

          if (
            response.toolCalls &&
            response.toolCalls.length > 0 &&
            response.toolCalls[0]?.toolName === "saveSlideContentAndNotes"
          ) {
            const args = response.toolCalls[0].args as {
              pageId: string;
              bodyContent: { type: string; text: string }[];
              refinedSpeakerNotes: string;
            };

            // Zod validation already happened by the tool infrastructure.
            // The bodyContent is now a validated array of objects.

            // 1. Update the slide's metadata with the structured body content (stringified) and refined speaker notes
            const metadataUpdateResult =
              // @ts-expect-error - tool parameters are typed as `any` for execute
              await runtimeTools.setSlideMetadata.execute({
                deckNodeKey: currentDeckNodeKey,
                slideId: args.pageId,
                slideMetadata: {
                  structuredBodyContent: JSON.stringify(args.bodyContent), // Stringify for metadata storage
                  speakerNotes: args.refinedSpeakerNotes,
                },
              });

            if (!metadataUpdateResult.success) {
              console.warn(
                `Failed to set metadata (structuredBodyContent, speakerNotes) for slide ${args.pageId}: ${metadataUpdateResult.error}`,
              );
              // Potentially increment contentGenerationErrors or throw if this is critical
            }

            generatedContents.push({
              pageId: args.pageId,
              structuredBodyContent: args.bodyContent, // Store the array directly in the workflow state
              refinedSpeakerNotes: args.refinedSpeakerNotes,
            });

            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Structured content and notes saved for slide ${slideOutline.slideNumber} (pageId: ${args.pageId}).`,
              },
            });
          } else {
            throw new Error(
              `Expected tool call 'saveSlideContentAndNotes' for slide ${slideOutline.pageId}, but received different or no tool call.`,
            );
          }
        } catch (e) {
          contentGenerationErrors++;
          const errorMsg = e instanceof Error ? e.message : String(e);
          console.error(
            `Error processing slide ${slideOutline.slideNumber} (pageId: ${slideOutline.pageId}): ${errorMsg}`,
          );
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Error generating structured content for slide ${slideOutline.slideNumber} (pageId: ${slideOutline.pageId}) (Step 5): ${errorMsg}`,
            },
          });
        }
      }

      if (contentGenerationErrors > 0) {
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Warning: Structured content generation for ${contentGenerationErrors} slide(s) encountered errors. (Step 5)`,
          },
        });
      }

      setSlideContents(generatedContents);
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "assistant",
          content: `Step 5 Complete: Slide Writer finished generating structured content for ${generatedContents.length} slides (with ${contentGenerationErrors} errors).`,
        },
      });
      return generatedContents;
    },
    [chatDispatch, generateChatResponse, runtimeTools, setSlideContents],
  );

  const runStep6_MediaGenerator = useCallback(
    async (
      storyboardDataParam: StoryboardData,
      currentDeckNodeKey: string,
      currentThemeSettings: WorkflowThemeSettings | null,
    ): Promise<VisualAssetData[] | null> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 6: Media & Chart Generator...",
        },
      });

      const generatedAssets: VisualAssetData[] = [];
      let assetGenerationErrors = 0;

      if (
        !runtimeTools.saveImageGenerationRequest ||
        !runtimeTools.addChartToSlidePage
      ) {
        throw new Error(
          "Required tools (saveImageGenerationRequest, addChartToSlidePage) are not available for Media Generator.",
        );
      }

      const themeStyleHint = currentThemeSettings?.templateName
        ? ` The overall presentation style is '${currentThemeSettings.templateName}'.`
        : "";
      const themeColorsHint = currentThemeSettings?.colorPalette
        ? ` Key theme colors are: ${JSON.stringify(currentThemeSettings.colorPalette)}.`
        : "";

      for (const slideOutline of storyboardDataParam.slides) {
        if (!slideOutline.pageId) {
          console.warn(
            `Skipping media generation for slide ${slideOutline.slideNumber} ('${slideOutline.title}') as it has no pageId.`,
          );
          generatedAssets.push({
            pageId: "unknown",
            visualIdea: slideOutline.visualIdea,
            assetType: "none",
            error: "Missing pageId",
          });
          assetGenerationErrors++;
          continue;
        }
        if (
          !slideOutline.visualIdea ||
          slideOutline.visualIdea.trim().toLowerCase() === "none" ||
          slideOutline.visualIdea.trim() === ""
        ) {
          generatedAssets.push({
            pageId: slideOutline.pageId,
            visualIdea: slideOutline.visualIdea,
            assetType: "none",
          });
          continue; // No visual idea, skip asset generation for this slide
        }

        const prompt = `You are a Visual Asset Coordinator.
For slide ${slideOutline.slideNumber} titled "${slideOutline.title}", the visual idea is: "${slideOutline.visualIdea}".
${themeStyleHint}${themeColorsHint}

Based on this, decide if an image or a chart is most appropriate. 

~1.  If an IMAGE is best:~
    ~*   Craft a concise, descriptive prompt for an image generation model (like DALL-E). The prompt should incorporate the visual idea and relevant style hints.~
    ~*   Call the "saveImageGenerationRequest" tool with arguments: "pageId" (use "${slideOutline.pageId}"), "imagePrompt" (your crafted prompt), and "styleHint" (e.g., derived from theme like '${currentThemeSettings?.templateName || "general"}').~

2.  If a CHART (bar, line, pie, etc.) is best:
    *   Determine the "chartType".
    *   Synthesize plausible "chartDataJSON" based on the visual idea. This should be a JSON string representing an array of data objects suitable for the chart type (e.g., for a bar chart: '[{"name": "A", "value": 10}, ...]'). Keep data simple (3-5 data points) unless specified otherwise.
    *   Suggest a simple "chartConfigJSON" if applicable (e.g., for Recharts, defining colors or labels as a JSON string: '{"value": {"label": "Sales", "color": "${currentThemeSettings?.colorPalette?.accent || "#8884d8"}"}}'). Often an empty object string '{}' is fine.
    *   Call the "addChartToSlidePage" tool with arguments: "deckNodeKey" (use "${currentDeckNodeKey}"), "slideId" (use "${slideOutline.pageId}"), "chartType", "chartDataJSON", "chartConfigJSON". You can also specify "x", "y", "width", "height" (e.g. x:100, y:200, width:500, height:300) or let the layout engine handle it later. For now, use x:100, y:200, width:500, height:300 if you call this tool.

Choose only ONE tool to call: either ~"saveImageGenerationRequest"~ OR "addChartToSlidePage". 
For now, the "saveImageGenerationRequest" tool is disabled.`;

        try {
          const response = await generateChatResponse({
            prompt,
            tools: {
              saveImageGenerationRequest:
                runtimeTools.saveImageGenerationRequest,
              addChartToSlidePage: runtimeTools.addChartToSlidePage,
            } as RuntimeToolMap,
          });

          if (response.toolCalls && response.toolCalls.length > 0) {
            const toolCall = response.toolCalls[0];
            if (toolCall?.toolName === "saveImageGenerationRequest") {
              const args = toolCall.args as {
                pageId: string;
                imagePrompt: string;
                styleHint?: string;
              };
              // TODO: In a real implementation, call an image generation service here with args.imagePrompt,
              // then get the imageUrl, and then call runtimeTools.addImageToSlidePage.
              // For now, we'll just record the request.
              generatedAssets.push({
                pageId: args.pageId,
                assetType: "image",
                visualIdea: slideOutline.visualIdea,
                imagePrompt: args.imagePrompt,
                styleHint: args.styleHint,
                // imageUrl: placeholderUrl, // Would be set after actual generation
              });
              chatDispatch({
                type: "push",
                msg: {
                  id: crypto.randomUUID(),
                  role: "assistant",
                  content: `Slide ${slideOutline.slideNumber} (Page ID: ${args.pageId}): Image generation requested. Prompt: "${args.imagePrompt.substring(0, 100)}..."`,
                },
              });
            } else if (toolCall?.toolName === "addChartToSlidePage") {
              const args = toolCall.args as {
                deckNodeKey: string;
                slideId: string;
                chartType: string;
                chartDataJSON: string;
                chartConfigJSON: string;
                x?: number;
                y?: number;
                width?: number;
                height?: number;
              };

              // Find the result of this specific tool call to get the newNodeKey
              let actualChartId: string | undefined = undefined;
              let assetError: string | undefined = undefined;

              if (
                response.toolResults &&
                response.toolResults.length === 1 &&
                response.toolResults[0]?.toolName === "addChartToSlidePage"
              ) {
                const toolResult = response.toolResults[0];
                // Cast toolResult.result to the expected structure
                const typedToolExecuteResult =
                  toolResult.result as ToolExecutionResultForMedia;

                if (
                  typedToolExecuteResult.success &&
                  typedToolExecuteResult.content?.newNodeKey
                ) {
                  actualChartId = typedToolExecuteResult.content.newNodeKey;
                } else {
                  assetError = `addChartToSlidePage for slide ${args.slideId} did not succeed or return a newNodeKey. Result: ${JSON.stringify(toolResult.result)}`;
                  console.warn(assetError);
                }
              } else {
                assetError = `Expected one toolResult for addChartToSlidePage on slide ${args.slideId}, but found ${response.toolResults?.length || 0}. Tool Results: ${JSON.stringify(response.toolResults)}`;
                console.warn(assetError);
              }

              if (!actualChartId) {
                // Fallback if newNodeKey could not be determined
                actualChartId = `chart-on-${args.slideId}-FALLBACK-${Date.now()}`;
                if (!assetError) {
                  // If no specific error was set above, set a generic one
                  assetError = `Failed to retrieve a valid newNodeKey for chart on slide ${args.slideId}. Using fallback ID.`;
                }
              }

              generatedAssets.push({
                pageId: args.slideId,
                assetType: "chart",
                visualIdea: slideOutline.visualIdea,
                chartId: actualChartId, // Use the determined or fallback ID
                chartType: args.chartType,
                styleHint: slideOutline.styleHint,
                error: assetError, // Store the error message
              });
            } else {
              throw new Error(`Unexpected tool called: ${toolCall?.toolName}`);
            }
          } else {
            // LLM didn't call any tool, maybe visualIdea was not actionable
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "system",
                content: `Slide ${slideOutline.slideNumber} (Page ID: ${slideOutline.pageId}): No specific media tool called by LLM for visual idea: "${slideOutline.visualIdea}". Content: ${response.text}`,
              },
            });
            generatedAssets.push({
              pageId: slideOutline.pageId,
              assetType: "none",
              visualIdea: slideOutline.visualIdea,
              error: "LLM did not call a media tool. " + (response.text || ""),
            });
          }
        } catch (e) {
          assetGenerationErrors++;
          const errorMsg = e instanceof Error ? e.message : String(e);
          console.error(
            `Error processing media for slide ${slideOutline.slideNumber} (pageId: ${slideOutline.pageId}): ${errorMsg}`,
          );
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Error generating media for slide ${slideOutline.slideNumber} (pageId: ${slideOutline.pageId}): ${errorMsg}`,
            },
          });
          generatedAssets.push({
            pageId: slideOutline.pageId,
            assetType: "none",
            visualIdea: slideOutline.visualIdea,
            error: errorMsg,
          });
        }
      }

      if (assetGenerationErrors > 0) {
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Warning: Media generation for ${assetGenerationErrors} slide(s) encountered errors or was skipped.`,
          },
        });
      }

      setVisualAssetsData(generatedAssets);
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "assistant",
          content: `Step 6 Complete: Media Generator processed ${generatedAssets.filter((a) => a.assetType !== "none").length} visual ideas (with ${assetGenerationErrors} errors/skips).`,
        },
      });
      return generatedAssets;
    },
    [chatDispatch, generateChatResponse, runtimeTools],
  );

  const runStep7_LayoutEngine = useCallback(
    async (
      currentDeckNodeKey: string,
      allSlideContents: SlideContentData[] | null,
      allVisualAssets: VisualAssetData[] | null,
      currentThemeSettings: WorkflowThemeSettings | null,
    ): Promise<void> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content:
            "Starting Step 7: Layout Engine - Processing structured content and visuals...",
        },
      });

      if (
        !runtimeTools.addBoxToSlidePage ||
        !runtimeTools.updateBoxPropertiesOnSlidePage ||
        !runtimeTools.updateSlideElementProperties ||
        !runtimeTools.applyTextStyle
      ) {
        throw new Error(
          "Required tools (addBoxToSlidePage, updateBoxPropertiesOnSlidePage, updateSlideElementProperties, applyTextStyle) are not available for LayoutEngine.",
        );
      }

      const SLIDE_WIDTH = 1280;
      const SLIDE_HEIGHT = 720;
      const PADDING = 50;
      const GAP = 20;

      const pageIds = new Set<string>();
      if (allSlideContents)
        allSlideContents.forEach((sc) => pageIds.add(sc.pageId));
      if (allVisualAssets)
        allVisualAssets.forEach((va) => va.pageId && pageIds.add(va.pageId));

      let layoutErrors = 0;

      for (const pageId of pageIds) {
        const slideContentInfo = allSlideContents?.find(
          (sc) => sc.pageId === pageId,
        );
        const visualAssetInfo = allVisualAssets?.find(
          (va) =>
            va.pageId === pageId &&
            (va.assetType === "chart" || va.assetType === "image"),
        );

        try {
          const createdContentBoxKeys: string[] = [];
          let parsedContentBlocks: { type: string; text: string }[] = [];

          if (slideContentInfo?.structuredBodyContent) {
            // No longer need to parse, it's already an array of objects
            parsedContentBlocks = slideContentInfo.structuredBodyContent;
            if (!Array.isArray(parsedContentBlocks)) {
              layoutErrors++;
              console.error(
                `Internal error: structuredBodyContent for slide ${pageId} is not an array. Found: ${typeof parsedContentBlocks}`,
              );
              chatDispatch({
                type: "push",
                msg: {
                  id: crypto.randomUUID(),
                  role: "system",
                  content: `Internal error with structured content for slide ${pageId}. Skipping content layout for this slide.`,
                },
              });
              parsedContentBlocks = []; // Reset to empty array to prevent further issues
            }
          }

          let currentY = PADDING;
          const availableWidth = SLIDE_WIDTH - 2 * PADDING;

          const visualElementId =
            visualAssetInfo?.assetType === "chart"
              ? visualAssetInfo.chartId
              : visualAssetInfo?.imageId;
          const visualPresent = visualAssetInfo && visualElementId;

          for (const block of parsedContentBlocks) {
            if (
              !block.text ||
              typeof block.text !== "string" ||
              typeof block.type !== "string"
            ) {
              console.warn(
                `Skipping invalid content block on slide ${pageId}:`,
                block,
              );
              continue;
            }
            // TODO: Enhance addBoxToSlidePage to take type/style hints for more specific styling
            // For now, it uses default theme styling for text.
            // @ts-expect-error - tool parameters are typed as `any` for execute
            const boxResult = await runtimeTools.addBoxToSlidePage.execute({
              deckNodeKey: currentDeckNodeKey,
              slideId: pageId,
              initialTextContent: block.text, // Markdown for lists handled by addBoxToSlidePage's Lexical conversion
              // Initial minimal size/pos, layout logic below will adjust
              x: PADDING,
              y: PADDING,
              width: SLIDE_WIDTH - 2 * PADDING, // Default to full width initially
              height: 100, // Default small height
            });

            if (boxResult.success && boxResult.content?.newNodeKey) {
              const boxNodeKey = boxResult.content.newNodeKey;
              // Ensure addBoxToSlidePage is updated to return textNodeKey in its content object
              const textNodeKey = (
                boxResult.content as unknown as { textNodeKey?: string }
              )?.textNodeKey;

              if (textNodeKey) {
                // Determine styles based on block.type and theme
                let fontSize = "1em"; // Default font size
                let fontWeight = "normal";
                const fontStyle = "normal";
                // Use theme settings if available, otherwise undefined (applyTextStyle will skip)
                let fontFamily = currentThemeSettings?.fonts?.body;
                let color = currentThemeSettings?.colorPalette?.textBody;

                switch (block.type) {
                  case "heading1":
                    fontFamily =
                      currentThemeSettings?.fonts?.heading || fontFamily;
                    color =
                      currentThemeSettings?.colorPalette?.textHeader || color;
                    fontSize = "2em";
                    fontWeight = "bold";
                    break;
                  case "heading2":
                    fontFamily =
                      currentThemeSettings?.fonts?.heading || fontFamily;
                    color =
                      currentThemeSettings?.colorPalette?.textHeader || color;
                    fontSize = "1.5em";
                    fontWeight = "bold";
                    break;
                  case "paragraph":
                  case "bulletList": // Base text style for list items
                    // Defaults are already set based on theme's body/textBody
                    break;
                  default:
                    console.warn(
                      `[LayoutEngine] Unknown block type: ${block.type}. Applying default paragraph styles.`,
                    );
                    // Defaults are paragraph-like, so no specific changes needed here
                    break;
                }

                // @ts-expect-error - tool parameters are typed as `any` for execute
                await runtimeTools.applyTextStyle.execute({
                  anchorKey: textNodeKey,
                  editorKey: boxNodeKey, // Box node key acts as the editor context for the text node
                  fontFamily,
                  fontSize,
                  fontWeight,
                  fontStyle,
                  color,
                });
              } else {
                layoutErrors++;
                console.error(
                  `Failed to retrieve textNodeKey for slide ${pageId}: ${boxResult.error}`,
                );
              }
            } else {
              layoutErrors++;
              console.error(
                `Failed to create content box for slide ${pageId}, block type ${block.type}: ${boxResult.error}`,
              );
            }
          }

          if (createdContentBoxKeys.length > 0 && visualPresent) {
            const contentWidth = (availableWidth - GAP) / 2;
            const visualWidth = contentWidth;

            for (const boxKey of createdContentBoxKeys) {
              const updateRes =
                // @ts-expect-error - tool parameters are typed as `any` for execute
                await runtimeTools.updateBoxPropertiesOnSlidePage.execute({
                  deckNodeKey: currentDeckNodeKey,
                  slideId: pageId,
                  boxId: boxKey,
                  properties: {
                    x: PADDING,
                    y: currentY,
                    width: contentWidth,
                    height: 150,
                  },
                });
              if (!updateRes.success) layoutErrors++;
              currentY += 150 + GAP;
            }

            if (visualElementId) {
              const updateVisRes =
                // @ts-expect-error - tool parameters are typed as `any` for execute
                await runtimeTools.updateSlideElementProperties.execute({
                  deckNodeKey: currentDeckNodeKey,
                  slideId: pageId,
                  elementId: visualElementId,
                  kind: visualAssetInfo.assetType as "image" | "chart",
                  properties: {
                    x: PADDING + contentWidth + GAP,
                    y: PADDING,
                    width: visualWidth,
                    height: SLIDE_HEIGHT - 2 * PADDING,
                  },
                });
              if (!updateVisRes.success) layoutErrors++;
            }
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Applied two-column layout to slide ${pageId}.`,
              },
            });
          } else if (createdContentBoxKeys.length > 0) {
            for (const boxKey of createdContentBoxKeys) {
              const updateRes =
                // @ts-expect-error - tool parameters are typed as `any` for execute
                await runtimeTools.updateBoxPropertiesOnSlidePage.execute({
                  deckNodeKey: currentDeckNodeKey,
                  slideId: pageId,
                  boxId: boxKey,
                  properties: {
                    x: PADDING,
                    y: currentY,
                    width: availableWidth,
                    height: 150,
                  },
                });
              if (!updateRes.success) layoutErrors++;
              currentY += 150 + GAP;
            }
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Applied stacked full-width layout to content on slide ${pageId}.`,
              },
            });
          } else if (visualPresent && visualElementId) {
            const visualW = availableWidth * 0.7;
            const visualH = SLIDE_HEIGHT * 0.7;
            const updateVisRes =
              // @ts-expect-error - tool parameters are typed as `any` for execute
              await runtimeTools.updateSlideElementProperties.execute({
                deckNodeKey: currentDeckNodeKey,
                slideId: pageId,
                elementId: visualElementId,
                kind: visualAssetInfo.assetType as "image" | "chart",
                properties: {
                  x: PADDING + (availableWidth - visualW) / 2,
                  y: (SLIDE_HEIGHT - visualH) / 2,
                  width: visualW,
                  height: visualH,
                },
              });
            if (!updateVisRes.success) layoutErrors++;
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `Centered visual asset on slide ${pageId}.`,
              },
            });
          }
        } catch (e) {
          layoutErrors++;
          const errorMsg = e instanceof Error ? e.message : String(e);
          console.error(`Error laying out slide ${pageId}: ${errorMsg}`);
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Error applying layout to slide ${pageId}: ${errorMsg}`,
            },
          });
        }
      }

      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "assistant",
          content: `Step 7 Complete: Layout Engine finished applying layouts to ${pageIds.size} slide(s) (with ${layoutErrors} errors).`,
        },
      });
    },
    [chatDispatch, runtimeTools],
  );

  const runStep8_ReviewRefine = useCallback(
    async (
      _currentDeckNodeKey: string,
      _audienceData: AudienceData | null,
      _storyboardData: StoryboardData | null,
      _slideContents: SlideContentData[] | null,
      _themeSettings: WorkflowThemeSettings | null,
      _visualAssetsData: VisualAssetData[] | null,
    ): Promise<{ finalSummary: string }> => {
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Starting Step 8: Review & Refine...",
        },
      });

      // For now, this step is a placeholder.
      // Future enhancements could involve LLM-based review or user interaction.

      const summaryLines = [
        "Step 8: Review & Refine Complete (Placeholder)",
        `- Deck Node Key: ${_currentDeckNodeKey}`,
        `- Audience Big Idea: ${_audienceData?.bigIdea || "N/A"}`,
        `- Number of Slides in Storyboard: ${_storyboardData?.slides?.length || 0}`,
        `- Number of Slides with Generated Content: ${_slideContents?.length || 0}`,
        `- Theme Template: ${_themeSettings?.templateName || "N/A"}`,
        `- Visual Assets Processed: ${_visualAssetsData?.filter((va) => va.assetType !== "none").length || 0} (out of ${_visualAssetsData?.length || 0} visual ideas)`,
      ];

      const finalSummary = summaryLines.join("\n");

      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "assistant",
          content: finalSummary,
        },
      });

      return { finalSummary };
    },
    [chatDispatch],
  );

  const startSlideGeneration = useCallback(
    async (params: SlideGenerationParams) => {
      setIsLoading(true);
      chatDispatch({
        type: "push",
        msg: {
          id: crypto.randomUUID(),
          role: "system",
          content: "Slide generation workflow initiated...",
        },
      });

      let resolvedDeckNodeKey: string | null = deckNodeKey;
      let currentThemeSettings: WorkflowThemeSettings | null = null;

      try {
        if (params.existingDeckNodeKey) {
          resolvedDeckNodeKey = params.existingDeckNodeKey;
          setDeckNodeKey(resolvedDeckNodeKey);
        } else if (!resolvedDeckNodeKey) {
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: "Creating new slide deck...",
            },
          });
          if (!runtimeTools.insertSlideDeckNode) {
            throw new Error("insertSlideDeckNode tool is not available.");
          }
          const deckCreationResult =
            // @ts-expect-error - tool parameters are typed as `any` for execute
            await runtimeTools.insertSlideDeckNode.execute({
              relation: "appendRoot",
            });

          if (
            deckCreationResult.success &&
            deckCreationResult.content?.newNodeKey
          ) {
            resolvedDeckNodeKey = deckCreationResult.content.newNodeKey;
            setDeckNodeKey(resolvedDeckNodeKey);
            chatDispatch({
              type: "push",
              msg: {
                id: crypto.randomUUID(),
                role: "assistant",
                content: `New slide deck created with key: ${resolvedDeckNodeKey}`,
              },
            });
          } else {
            throw new Error(
              `Failed to create new slide deck: ${deckCreationResult.error || "Unknown error"}`,
            );
          }
        }

        if (!resolvedDeckNodeKey) {
          throw new Error(
            "Slide deck node key could not be resolved or created.",
          );
        }

        const step1Result = await runStep1_AudiencePlanner(
          params.topic,
          params.who,
          params.outcome,
          params.timebox,
        );
        if (!step1Result) throw new Error("Audience planning failed (step 1)");

        const deckMetadataForStep1: DeckStrategicMetadata = {
          bigIdea: step1Result.bigIdea,
          audiencePersonaSummary: step1Result.persona,
          targetSlideCount: step1Result.slideCount,
          recommendedTone: step1Result.tone,
          originalUserPrompt: `Topic: ${params.topic}, Audience: ${params.who}, Outcome: ${params.outcome}, Timebox: ${params.timebox}`,
        };

        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Setting initial deck metadata for deck: ${resolvedDeckNodeKey}...`,
          },
        });

        if (!runtimeTools.setDeckMetadata) {
          throw new Error("setDeckMetadata tool is not available.");
        }
        const setInitialMetadataResult =
          // @ts-expect-error - tool parameters are typed as `any` for execute
          await runtimeTools.setDeckMetadata.execute({
            deckNodeKey: resolvedDeckNodeKey,
            deckMetadata: deckMetadataForStep1,
          });

        if (!setInitialMetadataResult.success) {
          console.warn(
            `Failed to set initial deck metadata: ${setInitialMetadataResult.error || "Unknown error"}`,
          );
          chatDispatch({
            type: "push",
            msg: {
              id: crypto.randomUUID(),
              role: "system",
              content: `Warning: Could not set initial deck metadata. ${setInitialMetadataResult.error || "Unknown error"}`,
            },
          });
        }
        currentThemeSettings = await runStep2_StyleStylist(
          resolvedDeckNodeKey,
          step1Result,
        );
        if (!currentThemeSettings)
          throw new Error("Style Stylist failed (step 2)");

        const step2Result = await runStep3_ResearchAgent(
          step1Result,
          params.files,
        );
        if (!step2Result) throw new Error("Research failed (step 2)");

        const step3Result = await runStep4_StoryboardArchitect(
          step2Result,
          step1Result.slideCount,
          resolvedDeckNodeKey,
        );
        if (!step3Result)
          throw new Error("Storyboard Architect failed (step 3)");

        const step4Result = await runStep5_SlideWriter(
          step3Result,
          resolvedDeckNodeKey,
        );
        if (!step4Result) throw new Error("Slide Writer failed (step 4)");

        let visualAssetsData: VisualAssetData[] | null = null;
        if (step3Result && resolvedDeckNodeKey && currentThemeSettings) {
          visualAssetsData = await runStep6_MediaGenerator(
            step3Result,
            resolvedDeckNodeKey,
            currentThemeSettings,
          );
        }

        await runStep7_LayoutEngine(
          resolvedDeckNodeKey,
          step4Result,
          visualAssetsData,
          currentThemeSettings,
        );

        const step8Result = await runStep8_ReviewRefine(
          resolvedDeckNodeKey,
          step1Result,
          step3Result,
          step4Result,
          currentThemeSettings,
          visualAssetsData,
        );
        if (!step8Result) throw new Error("Review & Refine failed (step 8)");

        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Slide generation workflow steps concluded. Final summary from Review & Refine: ${step8Result.finalSummary}`,
          },
        });
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        console.error("Slide generation workflow failed:", error);
        chatDispatch({
          type: "push",
          msg: {
            id: crypto.randomUUID(),
            role: "system",
            content: `Workflow error: ${errorMsg}`,
          },
        });
      } finally {
        setIsLoading(false);
      }
    },
    [
      chatDispatch,
      runStep1_AudiencePlanner,
      runStep3_ResearchAgent,
      runStep4_StoryboardArchitect,
      runStep5_SlideWriter,
      runStep2_StyleStylist,
      runStep6_MediaGenerator,
      runStep7_LayoutEngine,
      runStep8_ReviewRefine,
      deckNodeKey,
      runtimeTools,
    ],
  );

  return {
    startSlideGeneration,
    isLoading,
    audienceData,
    researchData,
    storyboardData,
    deckNodeKey,
    slideContents,
    themeSettings,
    visualAssetsData,
  };
}
